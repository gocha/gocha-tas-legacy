; wincheat.as: memory peeking for windows app
; written by gocha, feel free to redistribute


#ifndef WATCH_GETSET_INCLUDED
#define global WATCH_GETSET_INCLUDED

#include "wport.hsp"

goto *WATCH_GETSET_EOF

;---------------------------------------------------------------

#module Watch_GetSet

#const sizeof_PROCESSENTRY32        296
#const PE32__dwSize                 0   ; DWORD
#const PE32__cntUsage               1   ; DWORD
#const PE32__th32ProcessID          2   ; DWORD
#const PE32__th32DefaultHeapID      3   ; ULONG_PTR
#const PE32__th32ModuleID           4   ; DWORD
#const PE32__cntThreads             5   ; DWORD
#const PE32__th32ParentProcessID    6   ; DWORD
#const PE32__pcPriClassBase         7   ; LONG
#const PE32__dwFlags                8   ; DWORD
#const PE32__szExeFile              9   ; TCHAR[]

#defcfunc pathmatch str _p1, str _p2
	PathMatchSpec varptr(_p1), varptr(_p2) : result = stat
return result

#defcfunc get_pids array _p1, str _p2, int _p3

	targetExe = getpath(_p2, 16)
	pid_max = _p3
	pid_num = 0

	if (pid_max > 0) {
		CreateToolhelp32Snapshot TH32CS_SNAPPROCESS, 0 : hSnap = stat
		if (hSnap) {
			dim procEntry, (sizeof_PROCESSENTRY32 / HSP_SIZEOF_INT) + 1

			procEntry.PE32__dwSize = sizeof_PROCESSENTRY32
			Process32First hSnap, varptr(procEntry) : ret = stat
			repeat:if (ret == false) : break
				add_proc = (targetExe == "")

				getstr procExe, procEntry.PE32__szExeFile
				procExe = getpath(procExe, 16)

				PathMatchSpec varptr(procExe), varptr(targetExe)
				add_proc = add_proc | (stat != 0)

				if(add_proc) {
					_p1.pid_num = procEntry.PE32__th32ProcessID: pid_num++
					if(pid_num == pid_max) {
						break
					}
				}

				Process32Next hSnap, varptr(procEntry) : ret = stat
			loop

			CloseHandle hSnap
		}
	}

return pid_num

#deffunc proc_open var _p1, int _p2

	pid = _p2

	OpenProcess PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, 0, pid: hProc = stat
	_p1 = hProc

return (hProc != INVALID_HANDLE_VALUE)

#deffunc proc_close int _p1

	hProc = _p1

	CloseHandle hProc

return

#deffunc proc_memcpy int _p1, var _p2, int _p3, int _p4, int _p5, int _p6

	hProc = _p1
	dst_addr = varptr(_p2) + _p5
	src_addr = _p3 + _p6
	size = _p4

	ReadProcessMemory hProc, src_addr, dst_addr, size, varptr(readlen)

return (readlen == size)

*proc_npeek_rtn

	sx_val = 0: proc_memcpy _p1, sx_val, _p3, peek_size, 0, _p4: ret = stat

	if (peek_sx) {
		sx_size = peek_size
		gosub *signextend
	}

	_p2 = sx_val
return

*byteswap
	bswap_bytes.0 = (bswap_val) & 0xff
	bswap_bytes.1 = (bswap_val >> 8) & 0xff
	bswap_bytes.2 = (bswap_val >> 16) & 0xff
	bswap_bytes.3 = (bswap_val >> 24) & 0xff

	bswap_val = 0
	repeat bswap_size
		bswap_val = (bswap_val << 8)
		bswap_val += bswap_bytes.cnt
	loop
return

*signextend
	if (sx_size < 4) {
		sx_subv = 1 << (sx_size * 8)
		sx_sbit = sx_subv >> 1
		if (sx_val & sx_sbit): sx_val -= sx_subv
	}
return

#defcfunc bswap int _p1, int _p2
	bswap_val = _p1
	bswap_size = _p2
	gosub *byteswap
return bswap_val

#defcfunc intsx int _p1, int _p2
	sx_val = _p1
	sx_size = _p2
	gosub *signextend
return sx_val

#deffunc proc_npeek int _p1, var _p2, int _p3, int _p4, int _p5

	peek_size = _p5
	peek_sx = 0
	gosub *proc_npeek_rtn

return ret

#deffunc proc_npeeksx int _p1, var _p2, int _p3, int _p4, int _p5

	peek_size = _p5
	peek_sx = 1
	gosub *proc_npeek_rtn

return ret

#deffunc proc_peek int _p1, var _p2, int _p3, int _p4

	peek_size = 1
	peek_sx = 0
	gosub *proc_npeek_rtn

return ret

#deffunc proc_peeksx int _p1, var _p2, int _p3, int _p4

	peek_size = 1
	peek_sx = 1
	gosub *proc_npeek_rtn

return ret

#deffunc proc_wpeek int _p1, var _p2, int _p3, int _p4

	peek_size = 2
	peek_sx = 0
	gosub *proc_npeek_rtn

return ret

#deffunc proc_wpeeksx int _p1, var _p2, int _p3, int _p4

	peek_size = 2
	peek_sx = 1
	gosub *proc_npeek_rtn

return ret

#deffunc proc_3peek int _p1, var _p2, int _p3, int _p4

	peek_size = 3
	peek_sx = 0
	gosub *proc_npeek_rtn

return ret

#deffunc proc_3peeksx int _p1, var _p2, int _p3, int _p4

	peek_size = 3
	peek_sx = 1
	gosub *proc_npeek_rtn

return ret

#deffunc proc_lpeek int _p1, var _p2, int _p3, int _p4

	peek_size = 4
	peek_sx = 0
	gosub *proc_npeek_rtn

return ret

#deffunc proc_lpeeksx int _p1, var _p2, int _p3, int _p4

	peek_size = 4
	peek_sx = 1
	gosub *proc_npeek_rtn

return ret


#global

;---------------------------------------------------------------
*WATCH_GETSET_EOF
#endif // !WATCH_GETSET_INCLUDED
