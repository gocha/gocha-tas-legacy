;---------------------------------------------------------------
; wcore.hsp: Memory Watch I/O Core
;---------------------------------------------------------------

#ifndef WATCH_CORE_INCLUDED
#define global WATCH_CORE_INCLUDED

#include "wport.hsp"
#include "wutil.hsp"
#include "wgetset.hsp"

goto *WATCH_CORE_EOF

;---------------------------------------------------------------

#const  WM_RESET_MEMWATCH   (WM_APP+0)

;---------------------------------------------------------------
; >> check double running
;---------------------------------------------------------------
*prohibit_double_run
	app_hwnd = hwnd
	if(isdblrun(APP_NAME, app_hwnd)) {
		if (app_nodblrun) {
			PostMessage app_hwnd, WM_RESET_MEMWATCH, 0, 0
			__ABORT
		}
	}
return

;---------------------------------------------------------------
; >> search emulator processes
;---------------------------------------------------------------
*scan_emu
	watch_pid_num = 0

	; try for each filter
	repeat wtarget_num: wtarget_id = cnt: if (watch_pid_num >= WATCH_PROC_SYS_MAX): break
		watch_pid_num_temp = get_pids(watch_pid_temp, wtarget_fname.wtarget_id, WATCH_PROC_SYS_MAX)
		; is the pid emulator's one?
		repeat watch_pid_num_temp: if (watch_pid_num >= WATCH_PROC_SYS_MAX): break
			; already stored?
			new_pid = watch_pid_temp.cnt
			pid_already_exists = false
			repeat watch_pid_num
				if (watch_pid.cnt == new_pid) {
					pid_already_exists = true
					break
				}
			loop

			; add it, if not stored yet
			if (pid_already_exists == false) {
				watch_pid.watch_pid_num = new_pid
				watch_targetid.watch_pid_num = wtarget_id
				watch_pid_num++
			}
		loop
	loop

	gosub *getactemu
	gosub *setsizeauto
return

;---------------------------------------------------------------
; >> get active process
;---------------------------------------------------------------
*getactemu
	GetForegroundWindow : active_window = stat
	GetWindowThreadProcessId active_window, varptr(actpid)
	actprocall = -1
	if (watch_pid_num > 0) {
		repeat watch_pid_num: proc_cnt = cnt
			if (actpid == watch_pid.proc_cnt) {
				actprocall = proc_cnt
				break
			}
		loop
		if (actprocall != -1): actproc = actprocall
	}
	else {
		actproc = -1
	}
return

;---------------------------------------------------------------
; >> auto resize
;---------------------------------------------------------------
*setsizeauto
	autosized = false
//	if (watch_autosize == false) : return

	watch_requied_num = 0
	repeat watch_pid_num: proc_cnt = cnt
		watch_requied_num_proc = 0
		gui_gametitle = safeankif(wtarget_gametitle.proc_cnt)
		gui_gameid = safeankif(wtarget_gameid.proc_cnt)
		repeat watch_num: watch_id = cnt
			if ((watch_cmd.watch_id != WATCH_CMD_READ) & (watch_cmd.watch_id != WATCH_CMD_SEPARATOR)): continue
			watch_cur_gametitle = safeankif(watch_gametitle.watch_id)
			gosub *match_gametitle_port : if (gametitle_matched == false) : continue

			watch_requied_num_proc++
		loop
		if (watch_requied_num < watch_requied_num_proc) {
			watch_requied_num = watch_requied_num_proc
		}
	loop

	if ((watch_requied_num != 0) & (watch_max != watch_requied_num)) {
		watch_max = watch_requied_num
		autosized = true
	}

	if (watch_proc_max != watch_pid_num) {
		watch_proc_max = watch_pid_num
		autosized = true
	}

	if (autosized) {
		gosub *reset_gui
	}

	if (autosized) {
		watch_updated = true
	}
return

;---------------------------------------------------------------
; >> read variables
;---------------------------------------------------------------
*renew_vars
	repeat watch_pid_num: proc_cnt = cnt
		wtarget_id = watch_targetid.proc_cnt
		proc_open hProc, watch_pid.proc_cnt
		if stat {
			watch_updated_proc = false
			gosub *renew_vars_port_init
			repeat watch_num: watch_id = cnt
				if (watch_cmd.watch_id != WATCH_CMD_READ): continue
				if (watch_gametitle.watch_id != "") {
					if (((strlen(watch_gametitle.watch_id) != 4) | (watch_gametitle.watch_id != wtarget_gameid.proc_cnt)) & (watch_gametitle.watch_id != wtarget_gametitle.proc_cnt)): continue
				}

				gosub *lex_formula
				gosub *eval_formula

				; deprecated?
				if (watch_bigendian.watch_id) : watch_val = bswap(watch_val, watch_size.watch_id)

				if (watch_size.watch_id <= 2) {
					watch_wval = watch_val << ((2 - watch_size.watch_id) << 3)
				}
				else {
					watch_wval = shr(watch_val, (watch_size.watch_id - 2) << 3)
				}
				watch_wval = watch_wval & 0xFFFF
				if (watch_format.watch_id == WATCH_FORMAT_SINT) {
					watch_wval = watch_wval ^ 0x8000
				}
				if (watch_format.watch_id == WATCH_FORMAT_BOOL) {
					if (watch_wval): watch_wval = 0xFFFF
				}

				watch_var_old.proc_cnt.watch_id = watch_var.proc_cnt.watch_id
				watch_var.proc_cnt.watch_id = watch_val
				watch_wvar.proc_cnt.watch_id = watch_wval

				if (watch_var.proc_cnt.watch_id != watch_var_old.proc_cnt.watch_id) {
					watch_updated_proc = true
				}
			loop

			; update delta
			if (watch_updated_proc) {
				repeat watch_num: watch_id = cnt
					if (watch_cmd.watch_id != WATCH_CMD_READ): continue
					if (watch_gametitle.watch_id != "") {
						if (((strlen(watch_gametitle.watch_id) != 4) | (watch_gametitle.watch_id != wtarget_gameid.proc_cnt)) & (watch_gametitle.watch_id != wtarget_gametitle.proc_cnt)): continue
					}

					watch_var_delta.proc_cnt.watch_id = (watch_var.proc_cnt.watch_id - watch_var_old.proc_cnt.watch_id)
				loop
			}

			proc_close hProc
		}
	loop
	watch_updated = true
return

;---------------------------------------------------------------
; >> parse formula and make token list
;---------------------------------------------------------------
*lex_formula
	watch_formula_token_num = 0

	; FIXME: NYI
	watch_formula_token.0 = watch_formula.watch_id
	watch_formula_token_num = 1
return

;---------------------------------------------------------------
; >> eval formula
;---------------------------------------------------------------
*eval_formula
	watch_addr_str = watch_formula_token.0
	gosub *eval_formula_port_readaddr
	if (watch_format.watch_id == WATCH_FORMAT_SINT) : watch_val = intsx(watch_val, watch_size.watch_id)
return

;---------------------------------------------------------------
*WATCH_CORE_EOF
#endif // !WATCH_CORE_INCLUDED
